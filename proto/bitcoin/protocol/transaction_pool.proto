syntax = "proto3";

import "interface.proto";

package libbitcoin.protocol.blockchain.transaction_pool;

//! void transaction_pool::start();
message start_request {
}

message start_reply {
}

//! void transaction_pool::stop();
message stop_request {
}

message stop_reply {
}

//! void transaction_pool::inventory(message::inventory::ptr inventory);
message inventory_request {
  message inventory_vector {
    int32 type = 1;
    bytes hash = 2;
  }

  repeated inventory_vector inventories = 1;
}

message inventory_reply {
}

//! void transaction_pool::fetch(const hash_digest& tx_hash, fetch_handler handler);
message fetch_request {
  bytes transaction_hash = 1;
  string handler = 2;
}

message fetch_handler {
  int32 error = 1;
  tx transaction = 2;
}

//! void transaction_pool::fetch_history(const wallet::payment_address& address, size_t limit,
//!     size_t from_height, block_chain::history_fetch_handler handler);
message fetch_history_request {
  message payment_address {
    bool valid = 1;
    uint32 version = 2;
    bytes hash = 3;
  }

  payment_address address = 1;
  uint64 limit = 2;
  uint64 from_height = 3;
  string handler = 4;
}

message fetch_history_handler {
  message history_compact {
    uint32 kind = 1;
    point point = 2;
    uint64 height = 3;
    uint64 value = 4;
  }

  int32 error = 1;
  repeated history_compact history = 2;
}

//! void transaction_pool::exists(const hash_digest& tx_hash, result_handler handler);
message exists_request {
  bytes transaction_hash = 1;
  string handler = 2;
}

message exists_handler {
  int32 error = 1;
}

//! void transaction_pool::filter(message::get_data::ptr message, result_handler handler);
message filter_request {
  message inventory_vector {
    int32 type = 1;
    bytes hash = 2;
  }

  repeated inventory_vector message = 1;
  string handler = 2;
}

message filter_handler {
  int32 error = 1;
}

//! void transaction_pool::validate(transaction_ptr tx, validate_handler handler);
message validate_request {
  tx transaction = 1;
  string handler = 2;
}

message validate_handler {
  int32 error = 1;
  tx transaction = 2;
  repeated uint32 indexes = 3;
}

//! void transaction_pool::store(transaction_ptr tx, confirm_handler confirm_handler,
//!     validate_handler validate_handler);
message store_request {
  tx transaction = 1;
  string confirm_handler = 2;
  string validate_handler = 3;
}

message confirm_handler {
  int32 error = 1;
  tx transaction = 2;
}

//! void transaction_pool::subscribe_transaction(transaction_handler handler);
message subscribe_transaction_request {
  string handler = 1;
}

message subscribe_transaction_handler {
  int32 error = 1;
  repeated uint32 indexes = 2;
  tx transaction = 3;
}

//!
message request {
  oneof request_type {
    start_request start = 1;

    stop_request stop = 2;

    inventory_request inventory = 3;

    fetch_request fetch = 4;

    fetch_history_request fetch_history = 5;

    exists_request exists = 6;

    filter_request filter = 7;

    validate_request validate = 8;

    store_request store = 9;

    subscribe_transaction_request subscribe_transaction = 10;
  }
}
